import React, { useEffect, useState } from 'react'

import GameBoard from '@/components/game/Board'
import SettingsDialog from '@/components/game/SettingsDialog'
import Timer from '@/components/game/Timer'
import WinningScreen from '@/components/game/WinningScreen'
import ResetIcon from '@/components/icons/ResetIcon'
import { Board, createEmptyBoard, getQueenPositionForGivenX } from '@/lib/game/board'
import { checkWinCondition, getClashingQueens, Level } from '@/lib/game/logic'
import {
  useAutoPlaceXsPreference,
  useClashingQueensPreference,
  useShowClockPreference,
} from '@/hooks/useLocalStorage'
import EraserIcon from '../icons/EraserIcon'

const LevelBoard = ({
  id,
  level,
  onRefetch,
}: {
  id: string
  level: Level
  onRefetch?: () => Promise<void>
}) => {
  const [board, setBoard] = useState(createEmptyBoard(level.colorRegions, level.regionColors))
  const [, setQueenGeneratedXs] = useState({}) // Track Xs generated by each queen

  const [hasWon, setHasWon] = useState(false)
  const [timer, setTimer] = useState(1)
  const [showWinningScreen, setShowWinningScreen] = useState(false)
  const [clashingQueens, setClashingQueens] = useState<Set<string>>(new Set())

  const [showClashingQueens, setShowClashingQueens] = useClashingQueensPreference()
  const [showClock, setShowClock] = useShowClockPreference()
  const [autoPlaceXs, setAutoPlaceXs] = useAutoPlaceXsPreference()

  useEffect(() => {
    let interval: NodeJS.Timeout | undefined = undefined
    if (!hasWon) {
      interval = setInterval(() => {
        setTimer((prevSeconds) => {
          const newTime = prevSeconds + 1
          return newTime
        })
      }, 1000)
    } else if (hasWon) {
      clearInterval(interval)
    }

    return () => clearInterval(interval)
  }, [hasWon])

  useEffect(() => {
    setBoard(createEmptyBoard(level.colorRegions, level.regionColors))
    setHasWon(false)
    setShowWinningScreen(false)
    setTimer(0)
    setClashingQueens(new Set())
    setQueenGeneratedXs({})
  }, [level])

  // Handle click on square
  const handleSquareClick = (row: number, col: number) => {
    // Initialize newBoard as a copy of the current board
    const newBoard = structuredClone(board)

    const currentValue = board[row][col].value

    if (currentValue === ' ') {
      newBoard[row][col].value = 'X'
    } else if (currentValue === 'X') {
      placeQueen(newBoard, row, col)
    } else if (currentValue === 'Q') {
      removeQueen(newBoard, row, col)
    }

    // Check for win condition after updating the board
    if (checkWinCondition(newBoard)) {
      if (!hasWon) {
        setTimeout(() => setShowWinningScreen(true), 0)
      }
      setHasWon(true)
    } else {
      setHasWon(false)
      setShowWinningScreen(false)
    }

    // Update clashing queens
    const clashingPositions = getClashingQueens(newBoard)
    const clashingSet = new Set(clashingPositions.map(({ row, col }) => `${row},${col}`))
    setClashingQueens(clashingSet)

    setBoard(newBoard)
  }

  const handleDrag = (squares: number[][]) => {
    const newBoard = structuredClone(board)
    for (const [row, col] of squares) {
      if (newBoard[row][col].value !== 'Q') {
        newBoard[row][col].value = 'X'
      }
    }
    setBoard(newBoard)
  }

  const placeQueen = (newBoard: Board, row: number, col: number) => {
    newBoard[row][col].value = 'Q' // Place the queen

    if (!autoPlaceXs) return

    const newXs: number[][] = []
    const directions = [
      [-1, 0],
      [1, 0],
      [0, -1],
      [0, 1], // Row and column
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1], // Diagonals
    ]

    // Add X's around the queen
    directions.forEach(([dRow, dCol]) => {
      const xRow = row + dRow
      const xCol = col + dCol
      if (
        xRow >= 0 &&
        xRow < newBoard.length &&
        xCol >= 0 &&
        xCol < newBoard[0].length &&
        newBoard[xRow][xCol].value === ' '
      ) {
        newBoard[xRow][xCol].value = 'X'
        newXs.push([xRow, xCol])
      }
    })

    // Add X's in the row and column
    for (let i = 0; i < newBoard.length; i++) {
      if (newBoard[row][i].value === ' ') {
        newBoard[row][i].value = 'X'
        newXs.push([row, i])
      }
      if (newBoard[i][col].value === ' ') {
        newBoard[i][col].value = 'X'
        newXs.push([i, col])
      }
    }

    // Add X's in the same color region
    const queenRegion = newBoard[row][col].color
    for (let r = 0; r < newBoard.length; r++) {
      for (let c = 0; c < newBoard[0].length; c++) {
        if (
          newBoard[r][c].color === queenRegion && // Same region
          newBoard[r][c].value === ' ' // Empty square
        ) {
          newBoard[r][c].value = 'X'
          newXs.push([r, c])
        }
      }
    }

    // Track the X's generated by this queen
    setQueenGeneratedXs((prev) => {
      const updated: Record<string, Set<string>> = { ...prev }
      newXs.forEach(([xRow, xCol]) => {
        const key = `${xRow},${xCol}`
        if (!updated[key]) {
          updated[key] = new Set()
        }
        updated[key].add(`${row},${col}`)
      })
      return updated
    })
  }

  const removeQueen = (newBoard: Board, row: number, col: number) => {
    newBoard[row][col].value = ' ' // Remove the queen

    if (!autoPlaceXs) return

    const queenKey = `${row},${col}`

    setQueenGeneratedXs((prev) => {
      const updated: Record<string, Set<string>> = { ...prev }

      // Check all cells generated by this queen to see if they are needed by other queens
      Object.keys(updated).forEach((xKey) => {
        if (updated[xKey].has(queenKey)) {
          // Temporarily remove this queen's ownership
          updated[xKey].delete(queenKey)

          // Parse the coordinates of the 'X' cell
          const [xRow, xCol] = xKey.split(',').map(Number)

          const queenPos = getQueenPositionForGivenX(xRow, xCol, newBoard)

          // Check if any other queen still needs this 'X' cell
          if (!queenPos) {
            newBoard[xRow][xCol].value = ' ' // Remove X if no queens depend on it
            delete updated[xKey] // Remove entry if no queens left
          } else {
            updated[xKey].add(`${queenPos.x},${queenPos.y}`)
          }
        }
      })
      return updated
    })
  }

  const toggleClashingQueens = () => {
    const newSetting = !showClashingQueens
    setShowClashingQueens(newSetting)
  }

  const toggleShowClock = () => {
    const newSetting = !showClock
    setShowClock(newSetting)
  }

  const toggleAutoPlaceXs = () => {
    const newSetting = !autoPlaceXs
    setAutoPlaceXs(newSetting)
  }

  useEffect(() => {
    window.scrollTo(0, 0)
  }, [])

  useEffect(() => {
    // Update clashing queens
    const clashingPositions = getClashingQueens(board)
    const clashingSet = new Set(clashingPositions.map(({ row, col }) => `${row},${col}`))
    setClashingQueens(clashingSet)
  }, [board])

  return (
    <div key={id} className="flex flex-col items-center justify-center pt-4">
      <div className="flex flex-col items-center">
        <div>
          <div
            className={`flex w-full items-center space-x-4 py-4 sm:justify-between sm:space-x-0 ${
              showClock ? 'mb-0' : 'mb-2'
            }`}
          >
            <div className="flex items-center space-x-2">
              <Timer seconds={timer} />
            </div>

            <div className="flex flex-1 justify-end sm:flex-none">
              <div className="relative flex items-center">
                <button
                  onClick={onRefetch}
                  className="mr-2 rounded-full border border-slate-500 p-2"
                >
                  <ResetIcon size="18" />
                </button>
                <button
                  onClick={() => {
                    setBoard(createEmptyBoard(level.colorRegions, level.regionColors))
                    setHasWon(false)
                    setShowWinningScreen(false)
                  }}
                  className="mr-2 rounded-full border border-slate-500 p-2"
                >
                  <EraserIcon size="18" />
                </button>
                <SettingsDialog
                  showClashingQueens={showClashingQueens}
                  toggleShowClashingQueens={toggleClashingQueens}
                  showClock={showClock}
                  toggleShowClock={toggleShowClock}
                  autoPlaceXs={autoPlaceXs}
                  toggleAutoPlaceXs={toggleAutoPlaceXs}
                />
              </div>
            </div>
          </div>

          <div className="game relative">
            {showWinningScreen && (
              <WinningScreen
                timer={timer}
                close={() => setShowWinningScreen(false)}
                onRefetch={onRefetch}
              />
            )}
            <GameBoard
              board={board}
              handleSquareClick={handleSquareClick}
              handleSquareMouseEnter={handleDrag}
              showClashingQueens={showClashingQueens}
              clashingQueens={clashingQueens}
            />
          </div>
        </div>
      </div>
    </div>
  )
}

export default LevelBoard
